Типы ссылок в Java: StrongReference, WeakReference, SoftReference и PhantomReference
 27/08/2017  javadevbloger  Java
В Java есть 4 типа ссылок: Strong — сильная ссылка (мы чаще всего ею пользуемся) и 3 типа специальных ссылок:
WeakReference,
SoftReference,
PhantomReference. В этой статье мы узнаем зачом они нужны и где их желательно использовать.


Типы ссылок в Java
Сборщик мусора в Java чаще всего работает со Strong References или же сильными ссылками. Там все понятно и просто:
создаем ссылку на объект, что-то делаем с ним и потом, когда ссылка будет указывать на null и других ссылок на этот
объект не будет — освобождаем память.

Любой объект, к которому прилагается Сильная ссылка, не имеет права на сбор мусора. Например:

Java
String title = "Программирование на Java"
1
String title = "Программирование на Java"
Здесь ссылочная переменная title имеет сильную ссылку на объект String «Программирование на Java«;

В других случаях сборщику мусора нужно принять решение на основании того, какие ссылки ссылаются на этот объект.

 WeakReference и SoftReference в Java
Для начала давайте рассмотрим разницу между WeakReference и SoftReference в Java.

Если вкратце, то сборщик мусора освободит память объекта, если на него указывают только слабые ссылки. Когда на объект
указывают ссылки SoftReferences, то освобождение памяти происходит, когда JVM сильно нуждается в памяти.

Это дает определенное преимущество SoftReference перед Strong ссылкой в определенных случаях. Например, SoftReference
используют для реализации кэша приложений, поэтому JVM первым делом удалит объекты, на которые указывают только
SoftReferences.

WeakReference отлично подходит для хранения метаданных, например, для хранения ссылки на ClassLoader. Если ни один
класс не загружен, то не стоит ссылаться на ClassLoader. Именно поэтому WeakReference делает возможность сборщику
мусора выполнить свою работу с ClassLoader, как только на него удалится последняя сильная ссылка.

Пример WeakReference в Java:

Java
// какой-то объект
Student student = new Student();

// слабая ссылка на него
WeakReference<Student> weakStudent = new WeakReference<Student>(student);

// теперь объект Student может быть собран сборщиком мусора
student = null;
1
2
3
4
5
6
7
8
// какой-то объект
Student student = new Student();

// слабая ссылка на него
WeakReference<Student> weakStudent = new WeakReference<Student>(student);

// теперь объект Student может быть собран сборщиком мусора
student = null;
Пример SoftReference в Java:

Java
// какой-то объект
Student student = new Student();

// слабая ссылка на него
SoftReference<Student> softStudent = new SoftReference<Student>(student)

// теперь объект Student может быть собран сборщиком мусора
// но это случится только в случае сильной необходимости JVM в памяти
student = null;
1
2
3
4
5
6
7
8
9
// какой-то объект
Student student = new Student();

// слабая ссылка на него
SoftReference<Student> softStudent = new SoftReference<Student>(student)

// теперь объект Student может быть собран сборщиком мусора
// но это случится только в случае сильной необходимости JVM в памяти
student = null;
Ссылка PhantomReference в Java
Экземпляр PhantomReference создается точно также, как и на примерах WeakReference и SoftReference, но используется он
довольно редко.

PhantomReference может быть собрана сборщиком мусора, если на объект нет сильных (Strong), слабых ссылок (WeakReference)
 или мягких (SoftReference).

PhantomReference может использоваться в ситуациях, когда использование finalize() не имеет смысла. Этот ссылочный тип
отличается от других типов, поскольку он не предназначен для доступа к объекту. Он является сигналом о том, что объект
уже финализирован и сборщик мусора готов вернуть свою память.

Для этого сборщик мусора помещает его в специальный ReferenceQueue для последующей обработки. ReferenceQueue — это
место, куда помещаются ссылки на объекты для освобождение памяти.

Фантомные ссылки — это безопасный способ узнать, что объект удален из памяти. Например, рассмотрим приложение, которое
имеет дело с большими изображениями. Предположим, что мы хотим загрузить изображение в память, когда оно уже находится
в памяти, которая готова для сборки мусора. В этом случае мы хотим подождать пока сборщик мусора убьет старое
изображение и только потом загружать в память новое.

Здесь PhantomReference является гибким и безопасным выбором. Ссылка на старое изображение будет передана в
ReferenceQueue после уничтожения старого объекта изображения. Получив эту ссылку, мы можем загрузить новое
изображение в память.

Если вы узнали что-то новое из этой статьи про типы ссылок в Java, то подпишитесь на рассылку, чтобы ничего не
пропустить, а также на обновления сайта в соц. сетях — там публикуется больше интересных и полезных материалов!